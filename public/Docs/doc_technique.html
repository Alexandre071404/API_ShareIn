<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation Technique - Share'In</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }
        header {
            background-color: #09aecb;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 24px;
        }
        main {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background: white;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1, h2, li a {
            color: #09aecb;
        }
        h3 {
            color: #333;
        }
        ul, ol {
            margin-left: 20px;
        }
        code {
            background-color: #eee;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
        }
        .code-block {
            background-color: #272822;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .btn-back {
            display: inline-block;
            padding: 10px 15px;
            margin-top: 20px;
            background-color: #09aecb;
            color: white;
            text-decoration: none;
            border-radius: 5px;
        }
        .btn-back:hover {
            background-color: #005fa3;
        }
    </style>
</head>
<body>

<header>
    ğŸ› ï¸ Documentation Technique - Share'In
</header>

<main>
    <h1>Introduction</h1>
    <p>Ce document dÃ©crit l'architecture et les composants techniques de Share'In, une application de visioconfÃ©rence avec carte interactive.</p>

    <h2>ğŸ“Œ Table des MatiÃ¨res</h2>
    <ul>
        <li><a href="#technologies">Technologies UtilisÃ©es</a></li>
        <li><a href="#architecture">Architecture de l'Application</a></li>
        <li><a href="#backend">Backend</a></li>
        <li><a href="#frontend">Frontend</a></li>
        <li><a href="#communication">Communication Temps RÃ©el</a></li>
        <li><a href="#geolocalisation">GÃ©olocalisation</a></li>
    </ul>

    <h2 id="technologies">ğŸ–¥ï¸ Technologies UtilisÃ©es</h2>
    <ul>
        <li><strong>Frontend :</strong> HTML, CSS, JavaScript</li>
        <li><strong>Backend & API :</strong> Node.js</li>
        <li><strong>Temps rÃ©el :</strong> WebRTC, Socket.io</li>
        <li><strong>Carte interactive :</strong> Leaflet.js, OpenStreetMap</li>
    </ul>

    <h2 id="architecture">ğŸ—ï¸ Architecture de l'Application</h2>
    <p>Share'In est basÃ© sur une architecture client-serveur :</p>
    <ul>
        <li>Le **Frontend** gÃ¨re l'affichage des appels et de la carte.</li>
        <li>Le **Backend** gÃ¨re la signalisation WebRTC et les connexions WebSocket.</li>
        <li>Les **Sockets** permettent la communication temps rÃ©el.</li>
        <li>Leaflet.js est utilisÃ© pour afficher la carte interactive.</li>
    </ul>
    <p>Share'In a basÃ© son arborescence de la maniÃ¨re suivante :</p>
    <div class="code-block">
        ğŸ“‚ ShareIn/
        â”œâ”€â”€ ğŸ“ node_modules/          # Dossier contenant l'ensemble des Ã©lÃ©ments node
        â”œâ”€â”€ ğŸ“ public/
        â”‚   â”œâ”€â”€ ğŸ“ asset/            
        â”‚   â”‚   â”œâ”€â”€ ğŸ“ asset/        
        â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ Logo.png       # Logo Share'In
        â”‚   â”œâ”€â”€ ğŸ“ js/               
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ login.js       # Point d'entrÃ©e de l'application 
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ app.js         # GÃ¨re la liste des users et le dÃ©marage du socket
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ WebRTC.js      # Gestion de la Visio-confÃ©rence
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ chat.js        # Gestion du chat privÃ©
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ map.js         # Gestion de la carte intÃ©ractive
        â”‚   â”‚
        â”‚   â”œâ”€â”€ ğŸ“ Docs/                  # Documentation utilisateur et technique
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ doc_utilisateur.html
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ doc_technique.html
        â”‚   â”‚
        â”‚   â”œâ”€â”€ ğŸ“ style/                  # Style de l'application 
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ map.css             # Style de la page de l'application
        â”‚   â”‚   â”œâ”€â”€ ğŸ“„ style.css           # Style de l'Ã©cran de login
        â”‚   â”‚
        â”‚   â”œâ”€â”€ ğŸ“„ index.html              # Html du login
        â”‚   â”œâ”€â”€ ğŸ“„ map.html                # Html de l'application
        â”‚  
        â”œâ”€â”€ ğŸ“„ package-lock.json   # Verrouillage des versions des dÃ©pendances
        â”œâ”€â”€ ğŸ“„ package.json        # DÃ©pendances et scripts du projet
        â”œâ”€â”€ ğŸ“„ README.md           # Instructions pour lâ€™installation
        â”œâ”€â”€ ğŸ“„ server.js           # Serveur principal Node.js avec WebRTC et Socket.io
    </div>
    <p>
        L'arborescence du projet Share'In est organisÃ©e de maniÃ¨re Ã  sÃ©parer clairement les diffÃ©rentes responsabilitÃ©s de l'application. Le dossier <code>node_modules/</code> contient toutes les dÃ©pendances nÃ©cessaires au bon fonctionnement du projet, comme Express et Socket.io. <br>Le dossier <code>public/</code> regroupe les fichiers accessibles au navigateur, y compris les images, le JavaScript et les fichiers CSS. 
    </p>
    <p>
        Le dossier <code>js/</code> contient les fichiers JavaScript responsables des fonctionnalitÃ©s principales, telles que la gestion des utilisateurs, la visioconfÃ©rence et la carte interactive. <br>Le dossier <code>Docs/</code> propose deux fichiers de documentation : l'un pour l'utilisateur final et l'autre pour les dÃ©veloppeurs. 
    </p>
    <p>
        Le dossier <code>style/</code> contient les fichiers CSS pour le design visuel, assurant ainsi que chaque partie de l'application soit bien structurÃ©e et cohÃ©rente. Les fichiers <code>index.html</code> et <code>map.html</code> servent respectivement Ã  l'Ã©cran de login et Ã  l'interface de la visioconfÃ©rence. 
        <br>Enfin, les fichiers <code>package.json</code> et <code>package-lock.json</code> permettent de gÃ©rer les dÃ©pendances et les versions des modules Node.js, assurant une installation fiable du projet.
    </p>

    <h2 id="backend">âš™ï¸ Backend</h2>
    <p>Le serveur Node.js est responsable de la gestion des connexions et des Ã©changes entre utilisateurs.</p>

    <h3>Extrait du code (serveur Express + Socket.io)</h3>
    <div class="code-block">
        const express = require("express");
        const http = require("http");
        const { Server } = require("socket.io");
        const cors = require("cors");

        const app = express();
        const server = http.createServer(app);
        const io = new Server(server, {
            cors: {
                origin: "*",
                methods: ["GET", "POST"]
            }
        });
                    ......
        io.on("connection", (socket) => {
            console.log(`ğŸ”µ Connexion : ${socket.id}`);
        
            socket.on("/api/user_joined", (data) => {
            // Stocker dans les deux structures
            users[socket.id] = { 
                id: socket.id, 
                name: data.name, 
                latitude: null, 
                longitude: null,
                inCall: false
            };
            
            // Stocker ou mettre Ã  jour la rÃ©fÃ©rence par nom
            usersByName[data.name] = socket.id;
            
            console.log(`ğŸ‘¤ ${data.name} a rejoint la session`);
            io.emit("/api/users_list", users);
            io.emit("/api/positions_update", users);
            });

            socket.on("disconnect", () => {
                if (users[socket.id]) {
                  const userName = users[socket.id].name;
                  delete usersByName[userName];
                  delete users[socket.id];
                  io.emit("/api/users_list", users);
                  io.emit("/api/positions_update", users);
                  io.emit("/api/user-disconnected", socket.id);
                }
              });
        });         
    </div>
    <p>
        Ce script met en place un serveur de visioconfÃ©rence en utilisant <code>Express</code>, <code>Socket.io</code> et <code>CORS</code> pour gÃ©rer la communication en temps rÃ©el entre les utilisateurs.
    </p>

    <h3>Principaux composants :</h3>
    <ul>
        <li><strong>Initialisation :</strong> Le serveur Express est crÃ©Ã© avec <code>http.createServer(app)</code> et intÃ¨gre <code>Socket.io</code>.</li>
        <li><strong>Gestion du CORS :</strong> Le serveur accepte les connexions depuis n'importe quelle origine (<code>origin: "*"</code>) et prend en charge les requÃªtes <code>GET</code> et <code>POST</code>.</li>
    </ul>

    <h3>Gestion des connexions utilisateur</h3>
    <p>
        Ã€ chaque connexion d'un utilisateur, un identifiant unique est gÃ©nÃ©rÃ© et stockÃ©. Le serveur Ã©coute plusieurs Ã©vÃ©nements pour gÃ©rer les utilisateurs :
    </p>

    <ul>
        <li>
            <code>/api/user_joined</code> : Enregistre un nouvel utilisateur avec son <strong>nom</strong> et son <strong>ID de session</strong>.
        </li>
        <li>
            <code>/api/users_list</code> : Diffuse la liste des utilisateurs connectÃ©s Ã  tous les clients.
        </li>
        <li>
            <code>/api/positions_update</code> : Met Ã  jour les positions des utilisateurs sur la carte interactive.
        </li>
        <li>
            <code>disconnect</code> : Supprime l'utilisateur lorsqu'il quitte l'application et informe les autres participants.
        </li>
    </ul>
    <p>
        Ce systÃ¨me assure une communication fluide entre les utilisateurs en temps rÃ©el, permettant la mise Ã  jour des connexions et de la carte interactive sans recharger la page.
    </p>
    <h2 id="frontend">ğŸ¨ Frontend</h2>
    <p>Le frontend utilise **JavaScript** pour gÃ©rer l'interface utilisateur de maniÃ¨re dynamique.</p>

    <h3>Gestion de la vidÃ©o et des appels</h3>
    <div class="code-block">
        function createVideoElement(userId, userName) {
            // VÃ©rifier si l'Ã©lÃ©ment existe dÃ©jÃ 
            const existingContainer = document.getElementById(`container-${userId}`);
            if (existingContainer) {
                return existingContainer.querySelector('video');
            }
        
            const remoteVideo = document.createElement('video');
            remoteVideo.id = `remote-${userId}`;
            remoteVideo.autoplay = true;
            remoteVideo.playsinline = true;
            
            const videoContainer = document.createElement('div');
            videoContainer.className = 'remote-video-container';
            videoContainer.display = 'inline-block';
        
            videoContainer.id = `container-${userId}`;
            
            const nameLabel = document.createElement('div');
            nameLabel.className = 'name-label';
            nameLabel.textContent = userName;
            
            videoContainer.appendChild(remoteVideo);
            videoContainer.appendChild(nameLabel);
            document.getElementById('remoteVideos').appendChild(videoContainer);
            
            return remoteVideo;
        }
    </div>
    <p>
        Cette fonction permet de crÃ©er dynamiquement un Ã©lÃ©ment vidÃ©o pour afficher le flux dâ€™un utilisateur lors d'un appel vidÃ©o.
    </p>
    <h3>Ã‰tapes du processus :</h3>
    <ul>
        <li><strong>VÃ©rification prÃ©alable :</strong> VÃ©rifie si une vidÃ©o existe dÃ©jÃ  pour lâ€™utilisateur (<code>userId</code>). Si oui, elle est rÃ©utilisÃ©e.</li>
        <li><strong>CrÃ©ation de l'Ã©lÃ©ment vidÃ©o :</strong> Un Ã©lÃ©ment <code>&lt;video&gt;</code> est gÃ©nÃ©rÃ© avec les attributs <code>autoplay</code> et <code>playsinline</code> pour un affichage fluide.</li>
        <li><strong>Encapsulation dans un conteneur :</strong> Un <code>&lt;div&gt;</code> est crÃ©Ã© pour regrouper la vidÃ©o et un label affichant le nom de l'utilisateur.</li>
        <li><strong>Ajout au DOM :</strong> Le conteneur est ajoutÃ© Ã  lâ€™Ã©lÃ©ment <code>#remoteVideos</code>, qui affiche les flux des participants.</li>
    </ul>
    <p>
        GrÃ¢ce Ã  cette approche, chaque utilisateur a son propre espace vidÃ©o sans duplication, amÃ©liorant ainsi la gestion des flux vidÃ©o en confÃ©rence.
    </p>

    <h2 id="communication">ğŸ”„ Communication Temps RÃ©el</h2>
    <p>Share'In utilise **WebRTC** et **Socket.io** pour les Ã©changes entre utilisateurs.</p>

    <h3>Signalisation WebRTC</h3>
    <p>WebRTC est utilisÃ© pour Ã©tablir des connexions pair-Ã -pair :</p>
    <div class="code-block">
        socket.on('/api/user-connected', async ({ userId, userName }) => {
            console.log(`${userName} a rejoint l'appel`);
            
            // VÃ©rifier si une connexion existe dÃ©jÃ  pour cet utilisateur
            if (peers[userId]) {
                console.log('Connection existante trouvÃ©e, nettoyage...');
                peers[userId].close();
                delete peers[userId];
            }
            
            const peerConnection = new RTCPeerConnection(configuration);
            peers[userId] = peerConnection;
            
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    socket.emit('/api/ice-candidate', {
                        target: userId,
                        candidate: event.candidate
                    });
                }
            };
            
            peerConnection.ontrack = event => {
                const video = createVideoElement(userId, userName);
                video.srcObject = event.streams[0];
            };
            
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            socket.emit('/api/offer', {
                target: userId,
                offer: offer
            });
        });
    </div>
    <p>
        Le code gÃ¨re la connexion d'un nouvel utilisateur Ã  l'appel en utilisant WebRTC. Lorsqu'un utilisateur se connecte, un Ã©vÃ©nement <code>'/api/user-connected'</code> est Ã©mis. L'application vÃ©rifie d'abord si une connexion existante existe dÃ©jÃ  pour cet utilisateur. Si oui, elle la ferme pour Ã©viter les doublons.
    </p>
    <p>
        Ensuite, une nouvelle instance de <code>RTCPeerConnection</code> est crÃ©Ã©e pour Ã©tablir la connexion WebRTC avec l'utilisateur. La connexion locale est ensuite ajoutÃ©e Ã  cette instance, en envoyant chaque flux (comme la vidÃ©o et l'audio) Ã  l'utilisateur distant. Les Ã©vÃ©nements de type <code>onicecandidate</code> et <code>ontrack</code> gÃ¨rent respectivement l'Ã©change de candidats ICE (pour la traversÃ©e des pare-feux) et l'affichage du flux vidÃ©o distant.
    </p>
    <p>
        AprÃ¨s la configuration de la connexion, une offre WebRTC est crÃ©Ã©e, signÃ©e et envoyÃ©e Ã  l'utilisateur distant via un Ã©vÃ©nement <code>'/api/offer'</code>, dÃ©marrant ainsi la nÃ©gociation de la connexion entre les deux utilisateurs.
    </p>
    

    <h3>Messagerie instanÃ©e</h3>
    <p>La messagerie instanÃ©e se base sur le systÃ¨me de socket pour la gestion du back:</p>
    <div class="code-block">
        socket.on("/api/private_message", ({ to, from, message, toName }) => {
            // RÃ©cupÃ©rer l'ID socket actuel du destinataire par son nom
            const currentToId = usersByName[toName];
            
            if (users[from] && currentToId) {
                const conversationId = getConversationId(users[from].name, toName);
                
                if (!messageHistory[conversationId]) {
                    messageHistory[conversationId] = [];
                }
                
                const messageData = {
                    from: from,
                    fromName: users[from].name,
                    message: message,
                    timestamp: Date.now()
                };
                messageHistory[conversationId].push(messageData);
                io.to(currentToId).emit("/api/private_message", {
                    from: users[from].name,
                    message: message,
                    timestamp: messageData.timestamp
                });
                
                io.to(from).emit("/api/message_sent", {
                    to: toName,
                    message: message,
                    timestamp: messageData.timestamp
                });
            }
          });
    </div>
    <p>
        Le code gÃ¨re l'envoi de messages privÃ©s entre utilisateurs via un Ã©vÃ©nement <code>'/api/private_message'</code>. Lorsqu'un utilisateur envoie un message privÃ©, l'ID de l'utilisateur destinataire est rÃ©cupÃ©rÃ© par son nom grÃ¢ce Ã  <code>usersByName</code>.
    </p>
    <p>
        Si l'utilisateur expÃ©diteur et le destinataire sont valides, une conversation est identifiÃ©e (ou crÃ©Ã©e si elle n'existe pas) en fonction des noms des deux utilisateurs. L'historique des messages pour cette conversation est mis Ã  jour, et chaque message est ajoutÃ© Ã  cet historique.
    </p>
    <p>
        Le message est ensuite envoyÃ© Ã  l'utilisateur destinataire via un Ã©vÃ©nement <code>'/api/private_message'</code>, contenant le nom de l'expÃ©diteur, le message et un horodatage. Enfin, un Ã©vÃ©nement <code>'/api/message_sent'</code> est Ã©mis Ã  l'expÃ©diteur pour lui confirmer que son message a bien Ã©tÃ© envoyÃ©.
    </p>
    
    <h3>JavaScript pour la gestion du Front:</h3>
    <div class="code-block">
        function addMessageToChat(message, isSent, timestamp = new Date()) {
            const chatMessages = document.getElementById('chat-messages');
            const messageContainer = document.createElement('div');
            messageContainer.className = `message-container ${isSent ? 'sent' : 'received'}`;
        
            const messageElement = document.createElement('div');
            messageElement.className = 'message';
            messageElement.textContent = message;
        
            const timeElement = document.createElement('div');
            timeElement.className = 'message-time';
            timeElement.textContent = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
            messageContainer.appendChild(messageElement);
            messageContainer.appendChild(timeElement);
            chatMessages.appendChild(messageContainer);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    </div>
    <p>
        La fonction <code>addMessageToChat</code> permet d'ajouter un message dans le chat. Elle prend en paramÃ¨tres le message Ã  afficher, un indicateur pour savoir si le message a Ã©tÃ© envoyÃ© par l'utilisateur actuel (<code>isSent</code>), et un horodatage facultatif (<code>timestamp</code>).
    </p>
    <p>
        Un nouveau <code>div</code> est crÃ©Ã© pour chaque message. La classe CSS du conteneur du message est dÃ©finie en fonction de l'indicateur <code>isSent</code>, ce qui permet de diffÃ©rencier les messages envoyÃ©s de ceux reÃ§us. 
    </p>
    <p>
        Un autre <code>div</code> est ajoutÃ© pour afficher le texte du message. Enfin, un troisiÃ¨me <code>div</code> est crÃ©Ã© pour afficher l'heure du message au format de l'heure locale.
    </p>
    <p>
        Ces Ã©lÃ©ments sont ajoutÃ©s au conteneur principal du chat, et le conteneur est automatiquement dÃ©filÃ© vers le bas pour afficher le dernier message.
    </p>
    

    <h2 id="geolocalisation">ğŸ“ GÃ©olocalisation</h2>
    <p>Leaflet.js est utilisÃ© pour afficher la position des utilisateurs.</p>

    <h3>Afficher la carte interactive</h3>
    <div class="code-block">
        function initMap(latu,lngu) {
            try {
              // Initialiser la carte Leaflet
              this.map = L.map('map').setView([latu, lngu], 13);
              // Ajouter une couche de tuiles (OpenStreetMap)
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: "https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(this.map);
               const marker = L.marker([latu, lngu]).addTo(this.map);
               marker.bindPopup(`Vous Position:Latitude: ${latu}Longitude: ${lngu}`).openPopup();
              
            } catch (error) {
              console.error('Erreur Leaflet:', error);
              throw error;
            }
          }
    </div>
    <p>
        La fonction <code>initMap</code> est utilisÃ©e pour initialiser une carte interactive avec la bibliothÃ¨que Leaflet. Elle prend en paramÃ¨tres les coordonnÃ©es de latitude (<code>latu</code>) et de longitude (<code>lngu</code>) de l'utilisateur.
    </p>
    <p>
        La carte est d'abord initialisÃ©e avec un centre Ã  la position fournie et un niveau de zoom de 13. Ensuite, une couche de tuiles OpenStreetMap est ajoutÃ©e Ã  la carte pour afficher le fond de carte.
    </p>
    <p>
        Un marqueur est ensuite placÃ© Ã  la position de l'utilisateur, et une fenÃªtre contextuelle est liÃ©e au marqueur pour afficher les coordonnÃ©es de latitude et de longitude de l'utilisateur sous forme de message.
    </p>
    <p>
        En cas d'erreur lors de l'initialisation de la carte (par exemple, si les coordonnÃ©es sont incorrectes ou la bibliothÃ¨que Leaflet n'est pas chargÃ©e correctement), un message d'erreur est affichÃ© dans la console.
    </p>
    

    <h3>RÃ©ception des positions et mises Ã  jour depuis le serveur</h3>
    <div class="code-block">
        socket.on("/api/positions_update", (users) => {
            const displayedMarkers = new Set();
        
            Object.keys(users).forEach((id) => {
                const { latitude, longitude, name } = users[id];
                if (!latitude || !longitude || isNaN(latitude) || isNaN(longitude)) {
                    console.warn(`âš ï¸ CoordonnÃ©es invalides pour ${name || 
                        `Utilisateur ${id}`}:`, latitude, longitude);
                    return;
                }
                if (id === userId) return;
                if (!displayedMarkers.has(id)) {
                    const marker = L.marker([latitude, longitude]).addTo(this.map);
                    if (name===username){
                        marker.bindPopup(`Vous Position: Latitude: ${latitude} Longitude: ${longitude}`)
                        .openPopup();
                    }
                    else{
                        marker.bindPopup(`${name} Position: Latitude: ${latitude} Longitude: ${longitude}`)
                        .openPopup();
                    }
                    displayedMarkers.add(id); 
                }
            });
            
        });
    </div>
    <p>
        La fonction <code>socket.on("/api/positions_update", ...)</code> est utilisÃ©e pour recevoir les mises Ã  jour des positions des utilisateurs connectÃ©s. Chaque fois qu'un utilisateur met Ã  jour sa position, cette fonction est appelÃ©e pour afficher les nouveaux marqueurs sur la carte.
    </p>
    <p>
        Un <code>Set</code> nommÃ© <code>displayedMarkers</code> est utilisÃ© pour suivre les marqueurs dÃ©jÃ  affichÃ©s sur la carte afin d'Ã©viter d'afficher plusieurs fois un mÃªme marqueur pour un mÃªme utilisateur.
    </p>
    <p>
        Pour chaque utilisateur dans l'objet <code>users</code>, la fonction vÃ©rifie que les coordonnÃ©es de latitude et de longitude sont valides. Si les coordonnÃ©es sont invalides, un message d'avertissement est affichÃ© dans la console. Si l'utilisateur est celui qui a envoyÃ© la demande de mise Ã  jour (le <code>userId</code>), ses propres coordonnÃ©es ne sont pas affichÃ©es de nouveau.
    </p>
    <p>
        Si l'utilisateur n'est pas celui en cours, et si le marqueur n'a pas encore Ã©tÃ© affichÃ©, un nouveau marqueur est ajoutÃ© Ã  la carte Ã  la position indiquÃ©e par les coordonnÃ©es latitude et longitude de l'utilisateur. Si le nom de l'utilisateur correspond au nom de l'utilisateur connectÃ© (identifiÃ© par <code>username</code>), la fenÃªtre contextuelle affiche "Vous" pour indiquer que c'est votre propre position. Sinon, la fenÃªtre contextuelle affiche le nom de l'utilisateur et ses coordonnÃ©es.
    </p>
    <p>
        Cette fonctionnalitÃ© permet de mettre Ã  jour et de suivre en temps rÃ©el les positions des utilisateurs sur la carte, en Ã©vitant d'afficher plusieurs fois le mÃªme marqueur pour un mÃªme utilisateur.
    </p>
    <h3>RÃ©cupÃ©ration de la postion de l'utilisateur</h3>
    <div class="code-block">
        function getUserPosition() {
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        console.log(lat);
                        console.log(lng);
                        initMap(lat,lng);
                        updateUserPosition(lat, lng);
                        updateMap(lat, lng);
                        hideLoading();
                    },
                    (error) => {
                        console.error("âŒ Erreur de gÃ©olocalisation :", error);
                        if (error.code === 1) {
                            alert("âš ï¸ Vous avez refusÃ© l'accÃ¨s Ã  la gÃ©olocalisation. Activez-la dans les 
                            paramÃ¨tres de votre navigateur.");
                        } else if (error.code === 2) {
                            alert("âŒ Impossible d'obtenir votre position. VÃ©rifiez votre connexion GPS.");
                        } else if (error.code === 3) {
                            setTimeout(getUserPosition, 1);
                        }
                    },
                    {
                        timeout: 20000,
                        maximumAge: 5000 
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            } else {
                alert("GÃ©olocalisation non supportÃ©e par votre navigateur.");
            }
        }
    </div>
    <p>
        La fonction <code>getUserPosition()</code> permet d'obtenir la position gÃ©ographique actuelle de l'utilisateur en utilisant l'API de gÃ©olocalisation du navigateur. Cette fonction vÃ©rifie d'abord si la gÃ©olocalisation est disponible dans le navigateur, grÃ¢ce Ã  la propriÃ©tÃ© <code>navigator.geolocation</code>.
    </p>
    <p>
        Si la gÃ©olocalisation est disponible, la mÃ©thode <code>getCurrentPosition()</code> est appelÃ©e pour obtenir la position de l'utilisateur. Cette mÃ©thode prend en charge deux paramÃ¨tres de rappel : un pour la rÃ©ussite et un pour l'Ã©chec.
    </p>
    <p>
        - En cas de succÃ¨s, la fonction rÃ©cupÃ¨re les coordonnÃ©es de latitude et de longitude de la position de l'utilisateur via <code>position.coords.latitude</code> et <code>position.coords.longitude</code>. Elle affiche ces coordonnÃ©es dans la console, puis elle appelle plusieurs autres fonctions pour initialiser la carte, mettre Ã  jour la position de l'utilisateur et masquer l'interface de chargement (<code>hideLoading()</code>).
    </p>
    <p>
        - En cas d'Ã©chec, le callback d'erreur gÃ¨re diffÃ©rentes situations :
        <ul>
            <li><strong>Erreur code 1 :</strong> Si l'utilisateur a refusÃ© l'accÃ¨s Ã  la gÃ©olocalisation, un message l'avertit d'activer cette fonctionnalitÃ© dans les paramÃ¨tres du navigateur.</li>
            <li><strong>Erreur code 2 :</strong> Si le navigateur ne peut pas obtenir la position de l'utilisateur, cela peut Ãªtre dÃ» Ã  une mauvaise connexion GPS.</li>
            <li><strong>Erreur code 3 :</strong> Si l'appel Ã©choue aprÃ¨s un certain dÃ©lai, la fonction tente de rÃ©cupÃ©rer Ã  nouveau la position aprÃ¨s un dÃ©lai trÃ¨s court (1 milliseconde) soit quasiment instantanÃ©ment.</li>
        </ul>
    </p>
    <p>
        Si la gÃ©olocalisation n'est pas supportÃ©e par le navigateur, un message d'alerte est affichÃ© pour indiquer Ã  l'utilisateur que cette fonctionnalitÃ© n'est pas disponible.
    </p>
    

    <a href="index.html" class="btn-back">â†© Retour</a>

</main>

</body>
</html>
